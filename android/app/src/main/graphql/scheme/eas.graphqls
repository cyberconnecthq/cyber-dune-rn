extend type Query {
  aggregateAttestation(
    where: AttestationWhereInput
    orderBy: [AttestationOrderByWithRelationInput!]
    cursor: AttestationWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateAttestation!
  findFirstAttestation(
    where: AttestationWhereInput
    orderBy: [AttestationOrderByWithRelationInput!]
    cursor: AttestationWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AttestationScalarFieldEnum!]
  ): EasAttestation
  findFirstAttestationOrThrow(
    where: AttestationWhereInput
    orderBy: [AttestationOrderByWithRelationInput!]
    cursor: AttestationWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AttestationScalarFieldEnum!]
  ): EasAttestation
  attestations(
    where: AttestationWhereInput
    orderBy: [AttestationOrderByWithRelationInput!]
    cursor: AttestationWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AttestationScalarFieldEnum!]
  ): [Attestation!]!
  attestation(where: AttestationWhereUniqueInput!): EasAttestation
  getAttestation(where: AttestationWhereUniqueInput!): EasAttestation
  groupByAttestation(
    where: AttestationWhereInput
    orderBy: [AttestationOrderByWithAggregationInput!]
    by: [AttestationScalarFieldEnum!]!
    having: AttestationScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [AttestationGroupBy!]!
  aggregateEnsName(
    where: EnsNameWhereInput
    orderBy: [EnsNameOrderByWithRelationInput!]
    cursor: EnsNameWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateEnsName!
  findFirstEnsName(
    where: EnsNameWhereInput
    orderBy: [EnsNameOrderByWithRelationInput!]
    cursor: EnsNameWhereUniqueInput
    take: Int
    skip: Int
    distinct: [EnsNameScalarFieldEnum!]
  ): EnsName
  findFirstEnsNameOrThrow(
    where: EnsNameWhereInput
    orderBy: [EnsNameOrderByWithRelationInput!]
    cursor: EnsNameWhereUniqueInput
    take: Int
    skip: Int
    distinct: [EnsNameScalarFieldEnum!]
  ): EnsName
  ensNames(
    where: EnsNameWhereInput
    orderBy: [EnsNameOrderByWithRelationInput!]
    cursor: EnsNameWhereUniqueInput
    take: Int
    skip: Int
    distinct: [EnsNameScalarFieldEnum!]
  ): [EnsName!]!
  ensName(where: EnsNameWhereUniqueInput!): EnsName
  getEnsName(where: EnsNameWhereUniqueInput!): EnsName
  groupByEnsName(
    where: EnsNameWhereInput
    orderBy: [EnsNameOrderByWithAggregationInput!]
    by: [EnsNameScalarFieldEnum!]!
    having: EnsNameScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [EnsNameGroupBy!]!
  aggregateOffchainRevocation(
    where: OffchainRevocationWhereInput
    orderBy: [OffchainRevocationOrderByWithRelationInput!]
    cursor: OffchainRevocationWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateOffchainRevocation!
  findFirstOffchainRevocation(
    where: OffchainRevocationWhereInput
    orderBy: [OffchainRevocationOrderByWithRelationInput!]
    cursor: OffchainRevocationWhereUniqueInput
    take: Int
    skip: Int
    distinct: [OffchainRevocationScalarFieldEnum!]
  ): OffchainRevocation
  findFirstOffchainRevocationOrThrow(
    where: OffchainRevocationWhereInput
    orderBy: [OffchainRevocationOrderByWithRelationInput!]
    cursor: OffchainRevocationWhereUniqueInput
    take: Int
    skip: Int
    distinct: [OffchainRevocationScalarFieldEnum!]
  ): OffchainRevocation
  offchainRevocations(
    where: OffchainRevocationWhereInput
    orderBy: [OffchainRevocationOrderByWithRelationInput!]
    cursor: OffchainRevocationWhereUniqueInput
    take: Int
    skip: Int
    distinct: [OffchainRevocationScalarFieldEnum!]
  ): [OffchainRevocation!]!
  offchainRevocation(
    where: OffchainRevocationWhereUniqueInput!
  ): OffchainRevocation
  getOffchainRevocation(
    where: OffchainRevocationWhereUniqueInput!
  ): OffchainRevocation
  groupByOffchainRevocation(
    where: OffchainRevocationWhereInput
    orderBy: [OffchainRevocationOrderByWithAggregationInput!]
    by: [OffchainRevocationScalarFieldEnum!]!
    having: OffchainRevocationScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [OffchainRevocationGroupBy!]!
  aggregateSchema(
    where: SchemaWhereInput
    orderBy: [SchemaOrderByWithRelationInput!]
    cursor: SchemaWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateSchema!
  findFirstSchema(
    where: SchemaWhereInput
    orderBy: [SchemaOrderByWithRelationInput!]
    cursor: SchemaWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SchemaScalarFieldEnum!]
  ): Schema
  findFirstSchemaOrThrow(
    where: SchemaWhereInput
    orderBy: [SchemaOrderByWithRelationInput!]
    cursor: SchemaWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SchemaScalarFieldEnum!]
  ): Schema
  schemata(
    where: SchemaWhereInput
    orderBy: [SchemaOrderByWithRelationInput!]
    cursor: SchemaWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SchemaScalarFieldEnum!]
  ): [Schema!]!
  schema(where: SchemaWhereUniqueInput!): Schema
  getSchema(where: SchemaWhereUniqueInput!): Schema
  groupBySchema(
    where: SchemaWhereInput
    orderBy: [SchemaOrderByWithAggregationInput!]
    by: [SchemaScalarFieldEnum!]!
    having: SchemaScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [SchemaGroupBy!]!
  aggregateSchemaName(
    where: SchemaNameWhereInput
    orderBy: [SchemaNameOrderByWithRelationInput!]
    cursor: SchemaNameWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateSchemaName!
  findFirstSchemaName(
    where: SchemaNameWhereInput
    orderBy: [SchemaNameOrderByWithRelationInput!]
    cursor: SchemaNameWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SchemaNameScalarFieldEnum!]
  ): SchemaName
  findFirstSchemaNameOrThrow(
    where: SchemaNameWhereInput
    orderBy: [SchemaNameOrderByWithRelationInput!]
    cursor: SchemaNameWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SchemaNameScalarFieldEnum!]
  ): SchemaName
  schemaNames(
    where: SchemaNameWhereInput
    orderBy: [SchemaNameOrderByWithRelationInput!]
    cursor: SchemaNameWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SchemaNameScalarFieldEnum!]
  ): [SchemaName!]!
  schemaName(where: SchemaNameWhereUniqueInput!): SchemaName
  getSchemaName(where: SchemaNameWhereUniqueInput!): SchemaName
  groupBySchemaName(
    where: SchemaNameWhereInput
    orderBy: [SchemaNameOrderByWithAggregationInput!]
    by: [SchemaNameScalarFieldEnum!]!
    having: SchemaNameScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [SchemaNameGroupBy!]!
  aggregateServiceStat(
    where: ServiceStatWhereInput
    orderBy: [ServiceStatOrderByWithRelationInput!]
    cursor: ServiceStatWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateServiceStat!
  findFirstServiceStat(
    where: ServiceStatWhereInput
    orderBy: [ServiceStatOrderByWithRelationInput!]
    cursor: ServiceStatWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ServiceStatScalarFieldEnum!]
  ): ServiceStat
  findFirstServiceStatOrThrow(
    where: ServiceStatWhereInput
    orderBy: [ServiceStatOrderByWithRelationInput!]
    cursor: ServiceStatWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ServiceStatScalarFieldEnum!]
  ): ServiceStat
  serviceStats(
    where: ServiceStatWhereInput
    orderBy: [ServiceStatOrderByWithRelationInput!]
    cursor: ServiceStatWhereUniqueInput
    take: Int
    skip: Int
    distinct: [ServiceStatScalarFieldEnum!]
  ): [ServiceStat!]!
  serviceStat(where: ServiceStatWhereUniqueInput!): ServiceStat
  getServiceStat(where: ServiceStatWhereUniqueInput!): ServiceStat
  groupByServiceStat(
    where: ServiceStatWhereInput
    orderBy: [ServiceStatOrderByWithAggregationInput!]
    by: [ServiceStatScalarFieldEnum!]!
    having: ServiceStatScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [ServiceStatGroupBy!]!
  aggregateTimestamp(
    where: TimestampWhereInput
    orderBy: [TimestampOrderByWithRelationInput!]
    cursor: TimestampWhereUniqueInput
    take: Int
    skip: Int
  ): AggregateTimestamp!
  findFirstTimestamp(
    where: TimestampWhereInput
    orderBy: [TimestampOrderByWithRelationInput!]
    cursor: TimestampWhereUniqueInput
    take: Int
    skip: Int
    distinct: [TimestampScalarFieldEnum!]
  ): EasTimestamp
  findFirstTimestampOrThrow(
    where: TimestampWhereInput
    orderBy: [TimestampOrderByWithRelationInput!]
    cursor: TimestampWhereUniqueInput
    take: Int
    skip: Int
    distinct: [TimestampScalarFieldEnum!]
  ): EasTimestamp
  timestamps(
    where: TimestampWhereInput
    orderBy: [TimestampOrderByWithRelationInput!]
    cursor: TimestampWhereUniqueInput
    take: Int
    skip: Int
    distinct: [TimestampScalarFieldEnum!]
  ): [EasTimestamp!]!
  timestamp(where: TimestampWhereUniqueInput!): EasTimestamp
  getTimestamp(where: TimestampWhereUniqueInput!): EasTimestamp
  groupByTimestamp(
    where: TimestampWhereInput
    orderBy: [TimestampOrderByWithAggregationInput!]
    by: [TimestampScalarFieldEnum!]!
    having: TimestampScalarWhereWithAggregatesInput
    take: Int
    skip: Int
  ): [TimestampGroupBy!]!
}

type AggregateAttestation {
  _count: AttestationCountAggregate
  _avg: AttestationAvgAggregate
  _sum: AttestationSumAggregate
  _min: AttestationMinAggregate
  _max: AttestationMaxAggregate
}

type AttestationCountAggregate {
  id: Int!
  data: Int!
  decodedDataJson: Int!
  recipient: Int!
  attester: Int!
  time: Int!
  timeCreated: Int!
  expirationTime: Int!
  revocationTime: Int!
  refUID: Int!
  revocable: Int!
  revoked: Int!
  txid: Int!
  schemaId: Int!
  ipfsHash: Int!
  isOffchain: Int!
  _all: Int!
}

type AttestationAvgAggregate {
  time: Float
  timeCreated: Float
  expirationTime: Float
  revocationTime: Float
}

type AttestationSumAggregate {
  time: Int
  timeCreated: Int
  expirationTime: Int
  revocationTime: Int
}

type AttestationMinAggregate {
  id: String
  data: String
  decodedDataJson: String
  recipient: String
  attester: String
  time: Int
  timeCreated: Int
  expirationTime: Int
  revocationTime: Int
  refUID: String
  revocable: Boolean
  revoked: Boolean
  txid: String
  schemaId: String
  ipfsHash: String
  isOffchain: Boolean
}

type AttestationMaxAggregate {
  id: String
  data: String
  decodedDataJson: String
  recipient: String
  attester: String
  time: Int
  timeCreated: Int
  expirationTime: Int
  revocationTime: Int
  refUID: String
  revocable: Boolean
  revoked: Boolean
  txid: String
  schemaId: String
  ipfsHash: String
  isOffchain: Boolean
}

input AttestationWhereInput {
  AND: [AttestationWhereInput!]
  OR: [AttestationWhereInput!]
  NOT: [AttestationWhereInput!]
  id: StringFilter
  data: StringFilter
  decodedDataJson: StringFilter
  recipient: StringFilter
  attester: StringFilter
  time: IntFilter
  timeCreated: IntFilter
  expirationTime: IntFilter
  revocationTime: IntFilter
  refUID: StringFilter
  revocable: BoolFilter
  revoked: BoolFilter
  txid: StringFilter
  schemaId: StringFilter
  ipfsHash: StringFilter
  isOffchain: BoolFilter
  schema: SchemaRelationFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input NestedIntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input SchemaRelationFilter {
  is: SchemaWhereInput
  isNot: SchemaWhereInput
}

input SchemaWhereInput {
  AND: [SchemaWhereInput!]
  OR: [SchemaWhereInput!]
  NOT: [SchemaWhereInput!]
  id: StringFilter
  schema: StringFilter
  creator: StringFilter
  resolver: StringFilter
  revocable: BoolFilter
  index: StringFilter
  txid: StringFilter
  time: IntFilter
  attestations: AttestationListRelationFilter
  schemaNames: SchemaNameListRelationFilter
}

input AttestationListRelationFilter {
  every: AttestationWhereInput
  some: AttestationWhereInput
  none: AttestationWhereInput
}

input SchemaNameListRelationFilter {
  every: SchemaNameWhereInput
  some: SchemaNameWhereInput
  none: SchemaNameWhereInput
}

input SchemaNameWhereInput {
  AND: [SchemaNameWhereInput!]
  OR: [SchemaNameWhereInput!]
  NOT: [SchemaNameWhereInput!]
  id: StringFilter
  schemaId: StringFilter
  attesterAddress: StringFilter
  name: StringFilter
  time: IntFilter
  isCreator: BoolFilter
  schema: SchemaRelationFilter
}

input AttestationOrderByWithRelationInput {
  id: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  recipient: SortOrder
  attester: SortOrder
  time: SortOrder
  timeCreated: SortOrder
  expirationTime: SortOrder
  revocationTime: SortOrder
  refUID: SortOrder
  revocable: SortOrder
  revoked: SortOrder
  txid: SortOrder
  schemaId: SortOrder
  ipfsHash: SortOrder
  isOffchain: SortOrder
  schema: SchemaOrderByWithRelationInput
}

enum SortOrder {
  asc
  desc
}

input SchemaOrderByWithRelationInput {
  id: SortOrder
  schema: SortOrder
  creator: SortOrder
  resolver: SortOrder
  revocable: SortOrder
  index: SortOrder
  txid: SortOrder
  time: SortOrder
  attestations: AttestationOrderByRelationAggregateInput
  schemaNames: SchemaNameOrderByRelationAggregateInput
}

input AttestationOrderByRelationAggregateInput {
  _count: SortOrder
}

input SchemaNameOrderByRelationAggregateInput {
  _count: SortOrder
}

input AttestationWhereUniqueInput {
  id: String
}

type EasAttestation {
  id: String!
  data: String!
  decodedDataJson: String!
  recipient: String!
  attester: String!
  time: Int!
  timeCreated: Int!
  expirationTime: Int!
  revocationTime: Int!
  refUID: String!
  revocable: Boolean!
  revoked: Boolean!
  txid: String!
  schemaId: String!
  ipfsHash: String!
  isOffchain: Boolean!
  schema: Schema!
}

type Schema {
  id: String!
  schema: String!
  creator: String!
  resolver: String!
  revocable: Boolean!
  index: String!
  txid: String!
  time: Int!
  _count: SchemaCount
  attestations(
    where: AttestationWhereInput
    orderBy: [AttestationOrderByWithRelationInput!]
    cursor: AttestationWhereUniqueInput
    take: Int
    skip: Int
    distinct: [AttestationScalarFieldEnum!]
  ): [Attestation!]!
  schemaNames(
    where: SchemaNameWhereInput
    orderBy: [SchemaNameOrderByWithRelationInput!]
    cursor: SchemaNameWhereUniqueInput
    take: Int
    skip: Int
    distinct: [SchemaNameScalarFieldEnum!]
  ): [SchemaName!]!
}

type SchemaCount {
  attestations: Int!
  schemaNames: Int!
}

enum AttestationScalarFieldEnum {
  id
  data
  decodedDataJson
  recipient
  attester
  time
  timeCreated
  expirationTime
  revocationTime
  refUID
  revocable
  revoked
  txid
  schemaId
  ipfsHash
  isOffchain
}

type SchemaName {
  id: String!
  schemaId: String!
  attesterAddress: String!
  name: String!
  time: Int!
  isCreator: Boolean!
  schema: Schema!
}

input SchemaNameOrderByWithRelationInput {
  id: SortOrder
  schemaId: SortOrder
  attesterAddress: SortOrder
  name: SortOrder
  time: SortOrder
  isCreator: SortOrder
  schema: SchemaOrderByWithRelationInput
}

input SchemaNameWhereUniqueInput {
  id: String
}

enum SchemaNameScalarFieldEnum {
  id
  schemaId
  attesterAddress
  name
  time
  isCreator
}

type AttestationGroupBy {
  id: String!
  data: String!
  decodedDataJson: String!
  recipient: String!
  attester: String!
  time: Int!
  timeCreated: Int!
  expirationTime: Int!
  revocationTime: Int!
  refUID: String!
  revocable: Boolean!
  revoked: Boolean!
  txid: String!
  schemaId: String!
  ipfsHash: String!
  isOffchain: Boolean!
  _count: AttestationCountAggregate
  _avg: AttestationAvgAggregate
  _sum: AttestationSumAggregate
  _min: AttestationMinAggregate
  _max: AttestationMaxAggregate
}

input AttestationOrderByWithAggregationInput {
  id: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  recipient: SortOrder
  attester: SortOrder
  time: SortOrder
  timeCreated: SortOrder
  expirationTime: SortOrder
  revocationTime: SortOrder
  refUID: SortOrder
  revocable: SortOrder
  revoked: SortOrder
  txid: SortOrder
  schemaId: SortOrder
  ipfsHash: SortOrder
  isOffchain: SortOrder
  _count: AttestationCountOrderByAggregateInput
  _avg: AttestationAvgOrderByAggregateInput
  _max: AttestationMaxOrderByAggregateInput
  _min: AttestationMinOrderByAggregateInput
  _sum: AttestationSumOrderByAggregateInput
}

input AttestationCountOrderByAggregateInput {
  id: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  recipient: SortOrder
  attester: SortOrder
  time: SortOrder
  timeCreated: SortOrder
  expirationTime: SortOrder
  revocationTime: SortOrder
  refUID: SortOrder
  revocable: SortOrder
  revoked: SortOrder
  txid: SortOrder
  schemaId: SortOrder
  ipfsHash: SortOrder
  isOffchain: SortOrder
}

input AttestationAvgOrderByAggregateInput {
  time: SortOrder
  timeCreated: SortOrder
  expirationTime: SortOrder
  revocationTime: SortOrder
}

input AttestationMaxOrderByAggregateInput {
  id: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  recipient: SortOrder
  attester: SortOrder
  time: SortOrder
  timeCreated: SortOrder
  expirationTime: SortOrder
  revocationTime: SortOrder
  refUID: SortOrder
  revocable: SortOrder
  revoked: SortOrder
  txid: SortOrder
  schemaId: SortOrder
  ipfsHash: SortOrder
  isOffchain: SortOrder
}

input AttestationMinOrderByAggregateInput {
  id: SortOrder
  data: SortOrder
  decodedDataJson: SortOrder
  recipient: SortOrder
  attester: SortOrder
  time: SortOrder
  timeCreated: SortOrder
  expirationTime: SortOrder
  revocationTime: SortOrder
  refUID: SortOrder
  revocable: SortOrder
  revoked: SortOrder
  txid: SortOrder
  schemaId: SortOrder
  ipfsHash: SortOrder
  isOffchain: SortOrder
}

input AttestationSumOrderByAggregateInput {
  time: SortOrder
  timeCreated: SortOrder
  expirationTime: SortOrder
  revocationTime: SortOrder
}

input AttestationScalarWhereWithAggregatesInput {
  AND: [AttestationScalarWhereWithAggregatesInput!]
  OR: [AttestationScalarWhereWithAggregatesInput!]
  NOT: [AttestationScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  data: StringWithAggregatesFilter
  decodedDataJson: StringWithAggregatesFilter
  recipient: StringWithAggregatesFilter
  attester: StringWithAggregatesFilter
  time: IntWithAggregatesFilter
  timeCreated: IntWithAggregatesFilter
  expirationTime: IntWithAggregatesFilter
  revocationTime: IntWithAggregatesFilter
  refUID: StringWithAggregatesFilter
  revocable: BoolWithAggregatesFilter
  revoked: BoolWithAggregatesFilter
  txid: StringWithAggregatesFilter
  schemaId: StringWithAggregatesFilter
  ipfsHash: StringWithAggregatesFilter
  isOffchain: BoolWithAggregatesFilter
}

input StringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

input NestedStringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

input IntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input NestedFloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input BoolWithAggregatesFilter {
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedBoolFilter
  _max: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedBoolFilter
  _max: NestedBoolFilter
}

type AggregateEnsName {
  _count: EnsNameCountAggregate
  _avg: EnsNameAvgAggregate
  _sum: EnsNameSumAggregate
  _min: EnsNameMinAggregate
  _max: EnsNameMaxAggregate
}

type EnsNameCountAggregate {
  id: Int!
  name: Int!
  timestamp: Int!
  _all: Int!
}

type EnsNameAvgAggregate {
  timestamp: Float
}

type EnsNameSumAggregate {
  timestamp: Int
}

type EnsNameMinAggregate {
  id: String
  name: String
  timestamp: Int
}

type EnsNameMaxAggregate {
  id: String
  name: String
  timestamp: Int
}

input EnsNameWhereInput {
  AND: [EnsNameWhereInput!]
  OR: [EnsNameWhereInput!]
  NOT: [EnsNameWhereInput!]
  id: StringFilter
  name: StringFilter
  timestamp: IntFilter
}

input EnsNameOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  timestamp: SortOrder
}

input EnsNameWhereUniqueInput {
  id: String
}

type EnsName {
  id: String!
  name: String!
  timestamp: Int!
}

enum EnsNameScalarFieldEnum {
  id
  name
  timestamp
}

type EnsNameGroupBy {
  id: String!
  name: String!
  timestamp: Int!
  _count: EnsNameCountAggregate
  _avg: EnsNameAvgAggregate
  _sum: EnsNameSumAggregate
  _min: EnsNameMinAggregate
  _max: EnsNameMaxAggregate
}

input EnsNameOrderByWithAggregationInput {
  id: SortOrder
  name: SortOrder
  timestamp: SortOrder
  _count: EnsNameCountOrderByAggregateInput
  _avg: EnsNameAvgOrderByAggregateInput
  _max: EnsNameMaxOrderByAggregateInput
  _min: EnsNameMinOrderByAggregateInput
  _sum: EnsNameSumOrderByAggregateInput
}

input EnsNameCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  timestamp: SortOrder
}

input EnsNameAvgOrderByAggregateInput {
  timestamp: SortOrder
}

input EnsNameMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  timestamp: SortOrder
}

input EnsNameMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  timestamp: SortOrder
}

input EnsNameSumOrderByAggregateInput {
  timestamp: SortOrder
}

input EnsNameScalarWhereWithAggregatesInput {
  AND: [EnsNameScalarWhereWithAggregatesInput!]
  OR: [EnsNameScalarWhereWithAggregatesInput!]
  NOT: [EnsNameScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  timestamp: IntWithAggregatesFilter
}

type AggregateOffchainRevocation {
  _count: OffchainRevocationCountAggregate
  _avg: OffchainRevocationAvgAggregate
  _sum: OffchainRevocationSumAggregate
  _min: OffchainRevocationMinAggregate
  _max: OffchainRevocationMaxAggregate
}

type OffchainRevocationCountAggregate {
  id: Int!
  from: Int!
  uid: Int!
  txid: Int!
  timestamp: Int!
  _all: Int!
}

type OffchainRevocationAvgAggregate {
  timestamp: Float
}

type OffchainRevocationSumAggregate {
  timestamp: Int
}

type OffchainRevocationMinAggregate {
  id: String
  from: String
  uid: String
  txid: String
  timestamp: Int
}

type OffchainRevocationMaxAggregate {
  id: String
  from: String
  uid: String
  txid: String
  timestamp: Int
}

input OffchainRevocationWhereInput {
  AND: [OffchainRevocationWhereInput!]
  OR: [OffchainRevocationWhereInput!]
  NOT: [OffchainRevocationWhereInput!]
  id: StringFilter
  from: StringFilter
  uid: StringFilter
  txid: StringFilter
  timestamp: IntFilter
}

input OffchainRevocationOrderByWithRelationInput {
  id: SortOrder
  from: SortOrder
  uid: SortOrder
  txid: SortOrder
  timestamp: SortOrder
}

input OffchainRevocationWhereUniqueInput {
  id: String
}

type OffchainRevocation {
  id: String!
  from: String!
  uid: String!
  txid: String!
  timestamp: Int!
}

enum OffchainRevocationScalarFieldEnum {
  id
  from
  uid
  txid
  timestamp
}

type OffchainRevocationGroupBy {
  id: String!
  from: String!
  uid: String!
  txid: String!
  timestamp: Int!
  _count: OffchainRevocationCountAggregate
  _avg: OffchainRevocationAvgAggregate
  _sum: OffchainRevocationSumAggregate
  _min: OffchainRevocationMinAggregate
  _max: OffchainRevocationMaxAggregate
}

input OffchainRevocationOrderByWithAggregationInput {
  id: SortOrder
  from: SortOrder
  uid: SortOrder
  txid: SortOrder
  timestamp: SortOrder
  _count: OffchainRevocationCountOrderByAggregateInput
  _avg: OffchainRevocationAvgOrderByAggregateInput
  _max: OffchainRevocationMaxOrderByAggregateInput
  _min: OffchainRevocationMinOrderByAggregateInput
  _sum: OffchainRevocationSumOrderByAggregateInput
}

input OffchainRevocationCountOrderByAggregateInput {
  id: SortOrder
  from: SortOrder
  uid: SortOrder
  txid: SortOrder
  timestamp: SortOrder
}

input OffchainRevocationAvgOrderByAggregateInput {
  timestamp: SortOrder
}

input OffchainRevocationMaxOrderByAggregateInput {
  id: SortOrder
  from: SortOrder
  uid: SortOrder
  txid: SortOrder
  timestamp: SortOrder
}

input OffchainRevocationMinOrderByAggregateInput {
  id: SortOrder
  from: SortOrder
  uid: SortOrder
  txid: SortOrder
  timestamp: SortOrder
}

input OffchainRevocationSumOrderByAggregateInput {
  timestamp: SortOrder
}

input OffchainRevocationScalarWhereWithAggregatesInput {
  AND: [OffchainRevocationScalarWhereWithAggregatesInput!]
  OR: [OffchainRevocationScalarWhereWithAggregatesInput!]
  NOT: [OffchainRevocationScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  from: StringWithAggregatesFilter
  uid: StringWithAggregatesFilter
  txid: StringWithAggregatesFilter
  timestamp: IntWithAggregatesFilter
}

type AggregateSchema {
  _count: SchemaCountAggregate
  _avg: SchemaAvgAggregate
  _sum: SchemaSumAggregate
  _min: SchemaMinAggregate
  _max: SchemaMaxAggregate
}

type SchemaCountAggregate {
  id: Int!
  schema: Int!
  creator: Int!
  resolver: Int!
  revocable: Int!
  index: Int!
  txid: Int!
  time: Int!
  _all: Int!
}

type SchemaAvgAggregate {
  time: Float
}

type SchemaSumAggregate {
  time: Int
}

type SchemaMinAggregate {
  id: String
  schema: String
  creator: String
  resolver: String
  revocable: Boolean
  index: String
  txid: String
  time: Int
}

type SchemaMaxAggregate {
  id: String
  schema: String
  creator: String
  resolver: String
  revocable: Boolean
  index: String
  txid: String
  time: Int
}

input SchemaWhereUniqueInput {
  id: String
}

enum SchemaScalarFieldEnum {
  id
  schema
  creator
  resolver
  revocable
  index
  txid
  time
}

type SchemaGroupBy {
  id: String!
  schema: String!
  creator: String!
  resolver: String!
  revocable: Boolean!
  index: String!
  txid: String!
  time: Int!
  _count: SchemaCountAggregate
  _avg: SchemaAvgAggregate
  _sum: SchemaSumAggregate
  _min: SchemaMinAggregate
  _max: SchemaMaxAggregate
}

input SchemaOrderByWithAggregationInput {
  id: SortOrder
  schema: SortOrder
  creator: SortOrder
  resolver: SortOrder
  revocable: SortOrder
  index: SortOrder
  txid: SortOrder
  time: SortOrder
  _count: SchemaCountOrderByAggregateInput
  _avg: SchemaAvgOrderByAggregateInput
  _max: SchemaMaxOrderByAggregateInput
  _min: SchemaMinOrderByAggregateInput
  _sum: SchemaSumOrderByAggregateInput
}

input SchemaCountOrderByAggregateInput {
  id: SortOrder
  schema: SortOrder
  creator: SortOrder
  resolver: SortOrder
  revocable: SortOrder
  index: SortOrder
  txid: SortOrder
  time: SortOrder
}

input SchemaAvgOrderByAggregateInput {
  time: SortOrder
}

input SchemaMaxOrderByAggregateInput {
  id: SortOrder
  schema: SortOrder
  creator: SortOrder
  resolver: SortOrder
  revocable: SortOrder
  index: SortOrder
  txid: SortOrder
  time: SortOrder
}

input SchemaMinOrderByAggregateInput {
  id: SortOrder
  schema: SortOrder
  creator: SortOrder
  resolver: SortOrder
  revocable: SortOrder
  index: SortOrder
  txid: SortOrder
  time: SortOrder
}

input SchemaSumOrderByAggregateInput {
  time: SortOrder
}

input SchemaScalarWhereWithAggregatesInput {
  AND: [SchemaScalarWhereWithAggregatesInput!]
  OR: [SchemaScalarWhereWithAggregatesInput!]
  NOT: [SchemaScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  schema: StringWithAggregatesFilter
  creator: StringWithAggregatesFilter
  resolver: StringWithAggregatesFilter
  revocable: BoolWithAggregatesFilter
  index: StringWithAggregatesFilter
  txid: StringWithAggregatesFilter
  time: IntWithAggregatesFilter
}

type AggregateSchemaName {
  _count: SchemaNameCountAggregate
  _avg: SchemaNameAvgAggregate
  _sum: SchemaNameSumAggregate
  _min: SchemaNameMinAggregate
  _max: SchemaNameMaxAggregate
}

type SchemaNameCountAggregate {
  id: Int!
  schemaId: Int!
  attesterAddress: Int!
  name: Int!
  time: Int!
  isCreator: Int!
  _all: Int!
}

type SchemaNameAvgAggregate {
  time: Float
}

type SchemaNameSumAggregate {
  time: Int
}

type SchemaNameMinAggregate {
  id: String
  schemaId: String
  attesterAddress: String
  name: String
  time: Int
  isCreator: Boolean
}

type SchemaNameMaxAggregate {
  id: String
  schemaId: String
  attesterAddress: String
  name: String
  time: Int
  isCreator: Boolean
}

type SchemaNameGroupBy {
  id: String!
  schemaId: String!
  attesterAddress: String!
  name: String!
  time: Int!
  isCreator: Boolean!
  _count: SchemaNameCountAggregate
  _avg: SchemaNameAvgAggregate
  _sum: SchemaNameSumAggregate
  _min: SchemaNameMinAggregate
  _max: SchemaNameMaxAggregate
}

input SchemaNameOrderByWithAggregationInput {
  id: SortOrder
  schemaId: SortOrder
  attesterAddress: SortOrder
  name: SortOrder
  time: SortOrder
  isCreator: SortOrder
  _count: SchemaNameCountOrderByAggregateInput
  _avg: SchemaNameAvgOrderByAggregateInput
  _max: SchemaNameMaxOrderByAggregateInput
  _min: SchemaNameMinOrderByAggregateInput
  _sum: SchemaNameSumOrderByAggregateInput
}

input SchemaNameCountOrderByAggregateInput {
  id: SortOrder
  schemaId: SortOrder
  attesterAddress: SortOrder
  name: SortOrder
  time: SortOrder
  isCreator: SortOrder
}

input SchemaNameAvgOrderByAggregateInput {
  time: SortOrder
}

input SchemaNameMaxOrderByAggregateInput {
  id: SortOrder
  schemaId: SortOrder
  attesterAddress: SortOrder
  name: SortOrder
  time: SortOrder
  isCreator: SortOrder
}

input SchemaNameMinOrderByAggregateInput {
  id: SortOrder
  schemaId: SortOrder
  attesterAddress: SortOrder
  name: SortOrder
  time: SortOrder
  isCreator: SortOrder
}

input SchemaNameSumOrderByAggregateInput {
  time: SortOrder
}

input SchemaNameScalarWhereWithAggregatesInput {
  AND: [SchemaNameScalarWhereWithAggregatesInput!]
  OR: [SchemaNameScalarWhereWithAggregatesInput!]
  NOT: [SchemaNameScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  schemaId: StringWithAggregatesFilter
  attesterAddress: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  time: IntWithAggregatesFilter
  isCreator: BoolWithAggregatesFilter
}

type AggregateServiceStat {
  _count: ServiceStatCountAggregate
  _min: ServiceStatMinAggregate
  _max: ServiceStatMaxAggregate
}

type ServiceStatCountAggregate {
  name: Int!
  value: Int!
  _all: Int!
}

type ServiceStatMinAggregate {
  name: String
  value: String
}

type ServiceStatMaxAggregate {
  name: String
  value: String
}

input ServiceStatWhereInput {
  AND: [ServiceStatWhereInput!]
  OR: [ServiceStatWhereInput!]
  NOT: [ServiceStatWhereInput!]
  name: StringFilter
  value: StringFilter
}

input ServiceStatOrderByWithRelationInput {
  name: SortOrder
  value: SortOrder
}

input ServiceStatWhereUniqueInput {
  name: String
}

type ServiceStat {
  name: String!
  value: String!
}

enum ServiceStatScalarFieldEnum {
  name
  value
}

type ServiceStatGroupBy {
  name: String!
  value: String!
  _count: ServiceStatCountAggregate
  _min: ServiceStatMinAggregate
  _max: ServiceStatMaxAggregate
}

input ServiceStatOrderByWithAggregationInput {
  name: SortOrder
  value: SortOrder
  _count: ServiceStatCountOrderByAggregateInput
  _max: ServiceStatMaxOrderByAggregateInput
  _min: ServiceStatMinOrderByAggregateInput
}

input ServiceStatCountOrderByAggregateInput {
  name: SortOrder
  value: SortOrder
}

input ServiceStatMaxOrderByAggregateInput {
  name: SortOrder
  value: SortOrder
}

input ServiceStatMinOrderByAggregateInput {
  name: SortOrder
  value: SortOrder
}

input ServiceStatScalarWhereWithAggregatesInput {
  AND: [ServiceStatScalarWhereWithAggregatesInput!]
  OR: [ServiceStatScalarWhereWithAggregatesInput!]
  NOT: [ServiceStatScalarWhereWithAggregatesInput!]
  name: StringWithAggregatesFilter
  value: StringWithAggregatesFilter
}

type AggregateTimestamp {
  _count: TimestampCountAggregate
  _avg: TimestampAvgAggregate
  _sum: TimestampSumAggregate
  _min: TimestampMinAggregate
  _max: TimestampMaxAggregate
}

type TimestampCountAggregate {
  id: Int!
  from: Int!
  txid: Int!
  tree: Int!
  timestamp: Int!
  _all: Int!
}

type TimestampAvgAggregate {
  timestamp: Float
}

type TimestampSumAggregate {
  timestamp: Int
}

type TimestampMinAggregate {
  id: String
  from: String
  txid: String
  tree: String
  timestamp: Int
}

type TimestampMaxAggregate {
  id: String
  from: String
  txid: String
  tree: String
  timestamp: Int
}

input TimestampWhereInput {
  AND: [TimestampWhereInput!]
  OR: [TimestampWhereInput!]
  NOT: [TimestampWhereInput!]
  id: StringFilter
  from: StringFilter
  txid: StringFilter
  tree: StringFilter
  timestamp: IntFilter
}

input TimestampOrderByWithRelationInput {
  id: SortOrder
  from: SortOrder
  txid: SortOrder
  tree: SortOrder
  timestamp: SortOrder
}

input TimestampWhereUniqueInput {
  id: String
}

type EasTimestamp {
  id: String!
  from: String!
  txid: String!
  tree: String!
  timestamp: Int!
}

enum TimestampScalarFieldEnum {
  id
  from
  txid
  tree
  timestamp
}

type TimestampGroupBy {
  id: String!
  from: String!
  txid: String!
  tree: String!
  timestamp: Int!
  _count: TimestampCountAggregate
  _avg: TimestampAvgAggregate
  _sum: TimestampSumAggregate
  _min: TimestampMinAggregate
  _max: TimestampMaxAggregate
}

input TimestampOrderByWithAggregationInput {
  id: SortOrder
  from: SortOrder
  txid: SortOrder
  tree: SortOrder
  timestamp: SortOrder
  _count: TimestampCountOrderByAggregateInput
  _avg: TimestampAvgOrderByAggregateInput
  _max: TimestampMaxOrderByAggregateInput
  _min: TimestampMinOrderByAggregateInput
  _sum: TimestampSumOrderByAggregateInput
}

input TimestampCountOrderByAggregateInput {
  id: SortOrder
  from: SortOrder
  txid: SortOrder
  tree: SortOrder
  timestamp: SortOrder
}

input TimestampAvgOrderByAggregateInput {
  timestamp: SortOrder
}

input TimestampMaxOrderByAggregateInput {
  id: SortOrder
  from: SortOrder
  txid: SortOrder
  tree: SortOrder
  timestamp: SortOrder
}

input TimestampMinOrderByAggregateInput {
  id: SortOrder
  from: SortOrder
  txid: SortOrder
  tree: SortOrder
  timestamp: SortOrder
}

input TimestampSumOrderByAggregateInput {
  timestamp: SortOrder
}

input TimestampScalarWhereWithAggregatesInput {
  AND: [TimestampScalarWhereWithAggregatesInput!]
  OR: [TimestampScalarWhereWithAggregatesInput!]
  NOT: [TimestampScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  from: StringWithAggregatesFilter
  txid: StringWithAggregatesFilter
  tree: StringWithAggregatesFilter
  timestamp: IntWithAggregatesFilter
}

extend type Mutation {
  createManyAttestation(
    data: [AttestationCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createOneAttestation(data: AttestationCreateInput!): Attestation!
  deleteManyAttestation(where: AttestationWhereInput): AffectedRowsOutput!
  deleteOneAttestation(where: AttestationWhereUniqueInput!): EasAttestation
  updateManyAttestation(
    data: AttestationUpdateManyMutationInput!
    where: AttestationWhereInput
  ): AffectedRowsOutput!
  updateOneAttestation(
    data: AttestationUpdateInput!
    where: AttestationWhereUniqueInput!
  ): EasAttestation
  upsertOneAttestation(
    where: AttestationWhereUniqueInput!
    create: AttestationCreateInput!
    update: AttestationUpdateInput!
  ): Attestation!
  createManyEnsName(
    data: [EnsNameCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createOneEnsName(data: EnsNameCreateInput!): EnsName!
  deleteManyEnsName(where: EnsNameWhereInput): AffectedRowsOutput!
  deleteOneEnsName(where: EnsNameWhereUniqueInput!): EnsName
  updateManyEnsName(
    data: EnsNameUpdateManyMutationInput!
    where: EnsNameWhereInput
  ): AffectedRowsOutput!
  updateOneEnsName(
    data: EnsNameUpdateInput!
    where: EnsNameWhereUniqueInput!
  ): EnsName
  upsertOneEnsName(
    where: EnsNameWhereUniqueInput!
    create: EnsNameCreateInput!
    update: EnsNameUpdateInput!
  ): EnsName!
  createManyOffchainRevocation(
    data: [OffchainRevocationCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createOneOffchainRevocation(
    data: OffchainRevocationCreateInput!
  ): OffchainRevocation!
  deleteManyOffchainRevocation(
    where: OffchainRevocationWhereInput
  ): AffectedRowsOutput!
  deleteOneOffchainRevocation(
    where: OffchainRevocationWhereUniqueInput!
  ): OffchainRevocation
  updateManyOffchainRevocation(
    data: OffchainRevocationUpdateManyMutationInput!
    where: OffchainRevocationWhereInput
  ): AffectedRowsOutput!
  updateOneOffchainRevocation(
    data: OffchainRevocationUpdateInput!
    where: OffchainRevocationWhereUniqueInput!
  ): OffchainRevocation
  upsertOneOffchainRevocation(
    where: OffchainRevocationWhereUniqueInput!
    create: OffchainRevocationCreateInput!
    update: OffchainRevocationUpdateInput!
  ): OffchainRevocation!
  createManySchema(
    data: [SchemaCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createOneSchema(data: SchemaCreateInput!): Schema!
  deleteManySchema(where: SchemaWhereInput): AffectedRowsOutput!
  deleteOneSchema(where: SchemaWhereUniqueInput!): Schema
  updateManySchema(
    data: SchemaUpdateManyMutationInput!
    where: SchemaWhereInput
  ): AffectedRowsOutput!
  updateOneSchema(
    data: SchemaUpdateInput!
    where: SchemaWhereUniqueInput!
  ): Schema
  upsertOneSchema(
    where: SchemaWhereUniqueInput!
    create: SchemaCreateInput!
    update: SchemaUpdateInput!
  ): Schema!
  createManySchemaName(
    data: [SchemaNameCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createOneSchemaName(data: SchemaNameCreateInput!): SchemaName!
  deleteManySchemaName(where: SchemaNameWhereInput): AffectedRowsOutput!
  deleteOneSchemaName(where: SchemaNameWhereUniqueInput!): SchemaName
  updateManySchemaName(
    data: SchemaNameUpdateManyMutationInput!
    where: SchemaNameWhereInput
  ): AffectedRowsOutput!
  updateOneSchemaName(
    data: SchemaNameUpdateInput!
    where: SchemaNameWhereUniqueInput!
  ): SchemaName
  upsertOneSchemaName(
    where: SchemaNameWhereUniqueInput!
    create: SchemaNameCreateInput!
    update: SchemaNameUpdateInput!
  ): SchemaName!
  createManyServiceStat(
    data: [ServiceStatCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createOneServiceStat(data: ServiceStatCreateInput!): ServiceStat!
  deleteManyServiceStat(where: ServiceStatWhereInput): AffectedRowsOutput!
  deleteOneServiceStat(where: ServiceStatWhereUniqueInput!): ServiceStat
  updateManyServiceStat(
    data: ServiceStatUpdateManyMutationInput!
    where: ServiceStatWhereInput
  ): AffectedRowsOutput!
  updateOneServiceStat(
    data: ServiceStatUpdateInput!
    where: ServiceStatWhereUniqueInput!
  ): ServiceStat
  upsertOneServiceStat(
    where: ServiceStatWhereUniqueInput!
    create: ServiceStatCreateInput!
    update: ServiceStatUpdateInput!
  ): ServiceStat!
  createManyTimestamp(
    data: [TimestampCreateManyInput!]!
    skipDuplicates: Boolean
  ): AffectedRowsOutput!
  createOneTimestamp(data: TimestampCreateInput!): EasTimestamp!
  deleteManyTimestamp(where: TimestampWhereInput): AffectedRowsOutput!
  deleteOneTimestamp(where: TimestampWhereUniqueInput!): EasTimestamp
  updateManyTimestamp(
    data: TimestampUpdateManyMutationInput!
    where: TimestampWhereInput
  ): AffectedRowsOutput!
  updateOneTimestamp(
    data: TimestampUpdateInput!
    where: TimestampWhereUniqueInput!
  ): EasTimestamp
  upsertOneTimestamp(
    where: TimestampWhereUniqueInput!
    create: TimestampCreateInput!
    update: TimestampUpdateInput!
  ): EasTimestamp!
}

type AffectedRowsOutput {
  count: Int!
}

input AttestationCreateManyInput {
  id: String!
  data: String!
  decodedDataJson: String
  recipient: String!
  attester: String!
  time: Int!
  timeCreated: Int!
  expirationTime: Int!
  revocationTime: Int!
  refUID: String!
  revocable: Boolean!
  revoked: Boolean!
  txid: String!
  schemaId: String!
  ipfsHash: String!
  isOffchain: Boolean!
}

input AttestationCreateInput {
  id: String!
  data: String!
  decodedDataJson: String
  recipient: String!
  attester: String!
  time: Int!
  timeCreated: Int!
  expirationTime: Int!
  revocationTime: Int!
  refUID: String!
  revocable: Boolean!
  revoked: Boolean!
  txid: String!
  ipfsHash: String!
  isOffchain: Boolean!
  schema: SchemaCreateNestedOneWithoutAttestationsInput!
}

input SchemaCreateNestedOneWithoutAttestationsInput {
  create: SchemaCreateWithoutAttestationsInput
  connectOrCreate: SchemaCreateOrConnectWithoutAttestationsInput
  connect: SchemaWhereUniqueInput
}

input SchemaCreateWithoutAttestationsInput {
  id: String!
  schema: String!
  creator: String!
  resolver: String!
  revocable: Boolean!
  index: String!
  txid: String!
  time: Int!
  schemaNames: SchemaNameCreateNestedManyWithoutSchemaInput
}

input SchemaNameCreateNestedManyWithoutSchemaInput {
  create: [SchemaNameCreateWithoutSchemaInput!]
  connectOrCreate: [SchemaNameCreateOrConnectWithoutSchemaInput!]
  createMany: SchemaNameCreateManySchemaInputEnvelope
  connect: [SchemaNameWhereUniqueInput!]
}

input SchemaNameCreateWithoutSchemaInput {
  id: String
  attesterAddress: String!
  name: String!
  time: Int!
  isCreator: Boolean!
}

input SchemaNameCreateOrConnectWithoutSchemaInput {
  where: SchemaNameWhereUniqueInput!
  create: SchemaNameCreateWithoutSchemaInput!
}

input SchemaNameCreateManySchemaInputEnvelope {
  data: [SchemaNameCreateManySchemaInput!]!
  skipDuplicates: Boolean
}

input SchemaNameCreateManySchemaInput {
  id: String
  attesterAddress: String!
  name: String!
  time: Int!
  isCreator: Boolean!
}

input SchemaCreateOrConnectWithoutAttestationsInput {
  where: SchemaWhereUniqueInput!
  create: SchemaCreateWithoutAttestationsInput!
}

input AttestationUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  data: StringFieldUpdateOperationsInput
  decodedDataJson: StringFieldUpdateOperationsInput
  recipient: StringFieldUpdateOperationsInput
  attester: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  timeCreated: IntFieldUpdateOperationsInput
  expirationTime: IntFieldUpdateOperationsInput
  revocationTime: IntFieldUpdateOperationsInput
  refUID: StringFieldUpdateOperationsInput
  revocable: BoolFieldUpdateOperationsInput
  revoked: BoolFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  ipfsHash: StringFieldUpdateOperationsInput
  isOffchain: BoolFieldUpdateOperationsInput
}

input StringFieldUpdateOperationsInput {
  set: String
}

input IntFieldUpdateOperationsInput {
  set: Int
  increment: Int
  decrement: Int
  multiply: Int
  divide: Int
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input AttestationUpdateInput {
  id: StringFieldUpdateOperationsInput
  data: StringFieldUpdateOperationsInput
  decodedDataJson: StringFieldUpdateOperationsInput
  recipient: StringFieldUpdateOperationsInput
  attester: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  timeCreated: IntFieldUpdateOperationsInput
  expirationTime: IntFieldUpdateOperationsInput
  revocationTime: IntFieldUpdateOperationsInput
  refUID: StringFieldUpdateOperationsInput
  revocable: BoolFieldUpdateOperationsInput
  revoked: BoolFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  ipfsHash: StringFieldUpdateOperationsInput
  isOffchain: BoolFieldUpdateOperationsInput
  schema: SchemaUpdateOneRequiredWithoutAttestationsNestedInput
}

input SchemaUpdateOneRequiredWithoutAttestationsNestedInput {
  create: SchemaCreateWithoutAttestationsInput
  connectOrCreate: SchemaCreateOrConnectWithoutAttestationsInput
  upsert: SchemaUpsertWithoutAttestationsInput
  connect: SchemaWhereUniqueInput
  update: SchemaUpdateWithoutAttestationsInput
}

input SchemaUpsertWithoutAttestationsInput {
  update: SchemaUpdateWithoutAttestationsInput!
  create: SchemaCreateWithoutAttestationsInput!
}

input SchemaUpdateWithoutAttestationsInput {
  id: StringFieldUpdateOperationsInput
  schema: StringFieldUpdateOperationsInput
  creator: StringFieldUpdateOperationsInput
  resolver: StringFieldUpdateOperationsInput
  revocable: BoolFieldUpdateOperationsInput
  index: StringFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  schemaNames: SchemaNameUpdateManyWithoutSchemaNestedInput
}

input SchemaNameUpdateManyWithoutSchemaNestedInput {
  create: [SchemaNameCreateWithoutSchemaInput!]
  connectOrCreate: [SchemaNameCreateOrConnectWithoutSchemaInput!]
  upsert: [SchemaNameUpsertWithWhereUniqueWithoutSchemaInput!]
  createMany: SchemaNameCreateManySchemaInputEnvelope
  set: [SchemaNameWhereUniqueInput!]
  disconnect: [SchemaNameWhereUniqueInput!]
  delete: [SchemaNameWhereUniqueInput!]
  connect: [SchemaNameWhereUniqueInput!]
  update: [SchemaNameUpdateWithWhereUniqueWithoutSchemaInput!]
  updateMany: [SchemaNameUpdateManyWithWhereWithoutSchemaInput!]
  deleteMany: [SchemaNameScalarWhereInput!]
}

input SchemaNameUpsertWithWhereUniqueWithoutSchemaInput {
  where: SchemaNameWhereUniqueInput!
  update: SchemaNameUpdateWithoutSchemaInput!
  create: SchemaNameCreateWithoutSchemaInput!
}

input SchemaNameUpdateWithoutSchemaInput {
  id: StringFieldUpdateOperationsInput
  attesterAddress: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  isCreator: BoolFieldUpdateOperationsInput
}

input SchemaNameUpdateWithWhereUniqueWithoutSchemaInput {
  where: SchemaNameWhereUniqueInput!
  data: SchemaNameUpdateWithoutSchemaInput!
}

input SchemaNameUpdateManyWithWhereWithoutSchemaInput {
  where: SchemaNameScalarWhereInput!
  data: SchemaNameUpdateManyMutationInput!
}

input SchemaNameScalarWhereInput {
  AND: [SchemaNameScalarWhereInput!]
  OR: [SchemaNameScalarWhereInput!]
  NOT: [SchemaNameScalarWhereInput!]
  id: StringFilter
  schemaId: StringFilter
  attesterAddress: StringFilter
  name: StringFilter
  time: IntFilter
  isCreator: BoolFilter
}

input SchemaNameUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  attesterAddress: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  isCreator: BoolFieldUpdateOperationsInput
}

input EnsNameCreateManyInput {
  id: String!
  name: String!
  timestamp: Int!
}

input EnsNameCreateInput {
  id: String!
  name: String!
  timestamp: Int!
}

input EnsNameUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  timestamp: IntFieldUpdateOperationsInput
}

input EnsNameUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  timestamp: IntFieldUpdateOperationsInput
}

input OffchainRevocationCreateManyInput {
  id: String
  from: String!
  uid: String!
  txid: String!
  timestamp: Int!
}

input OffchainRevocationCreateInput {
  id: String
  from: String!
  uid: String!
  txid: String!
  timestamp: Int!
}

input OffchainRevocationUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  from: StringFieldUpdateOperationsInput
  uid: StringFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  timestamp: IntFieldUpdateOperationsInput
}

input OffchainRevocationUpdateInput {
  id: StringFieldUpdateOperationsInput
  from: StringFieldUpdateOperationsInput
  uid: StringFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  timestamp: IntFieldUpdateOperationsInput
}

input SchemaCreateManyInput {
  id: String!
  schema: String!
  creator: String!
  resolver: String!
  revocable: Boolean!
  index: String!
  txid: String!
  time: Int!
}

input SchemaCreateInput {
  id: String!
  schema: String!
  creator: String!
  resolver: String!
  revocable: Boolean!
  index: String!
  txid: String!
  time: Int!
  attestations: AttestationCreateNestedManyWithoutSchemaInput
  schemaNames: SchemaNameCreateNestedManyWithoutSchemaInput
}

input AttestationCreateNestedManyWithoutSchemaInput {
  create: [AttestationCreateWithoutSchemaInput!]
  connectOrCreate: [AttestationCreateOrConnectWithoutSchemaInput!]
  createMany: AttestationCreateManySchemaInputEnvelope
  connect: [AttestationWhereUniqueInput!]
}

input AttestationCreateWithoutSchemaInput {
  id: String!
  data: String!
  decodedDataJson: String
  recipient: String!
  attester: String!
  time: Int!
  timeCreated: Int!
  expirationTime: Int!
  revocationTime: Int!
  refUID: String!
  revocable: Boolean!
  revoked: Boolean!
  txid: String!
  ipfsHash: String!
  isOffchain: Boolean!
}

input AttestationCreateOrConnectWithoutSchemaInput {
  where: AttestationWhereUniqueInput!
  create: AttestationCreateWithoutSchemaInput!
}

input AttestationCreateManySchemaInputEnvelope {
  data: [AttestationCreateManySchemaInput!]!
  skipDuplicates: Boolean
}

input AttestationCreateManySchemaInput {
  id: String!
  data: String!
  decodedDataJson: String
  recipient: String!
  attester: String!
  time: Int!
  timeCreated: Int!
  expirationTime: Int!
  revocationTime: Int!
  refUID: String!
  revocable: Boolean!
  revoked: Boolean!
  txid: String!
  ipfsHash: String!
  isOffchain: Boolean!
}

input SchemaUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  schema: StringFieldUpdateOperationsInput
  creator: StringFieldUpdateOperationsInput
  resolver: StringFieldUpdateOperationsInput
  revocable: BoolFieldUpdateOperationsInput
  index: StringFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
}

input SchemaUpdateInput {
  id: StringFieldUpdateOperationsInput
  schema: StringFieldUpdateOperationsInput
  creator: StringFieldUpdateOperationsInput
  resolver: StringFieldUpdateOperationsInput
  revocable: BoolFieldUpdateOperationsInput
  index: StringFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  attestations: AttestationUpdateManyWithoutSchemaNestedInput
  schemaNames: SchemaNameUpdateManyWithoutSchemaNestedInput
}

input AttestationUpdateManyWithoutSchemaNestedInput {
  create: [AttestationCreateWithoutSchemaInput!]
  connectOrCreate: [AttestationCreateOrConnectWithoutSchemaInput!]
  upsert: [AttestationUpsertWithWhereUniqueWithoutSchemaInput!]
  createMany: AttestationCreateManySchemaInputEnvelope
  set: [AttestationWhereUniqueInput!]
  disconnect: [AttestationWhereUniqueInput!]
  delete: [AttestationWhereUniqueInput!]
  connect: [AttestationWhereUniqueInput!]
  update: [AttestationUpdateWithWhereUniqueWithoutSchemaInput!]
  updateMany: [AttestationUpdateManyWithWhereWithoutSchemaInput!]
  deleteMany: [AttestationScalarWhereInput!]
}

input AttestationUpsertWithWhereUniqueWithoutSchemaInput {
  where: AttestationWhereUniqueInput!
  update: AttestationUpdateWithoutSchemaInput!
  create: AttestationCreateWithoutSchemaInput!
}

input AttestationUpdateWithoutSchemaInput {
  id: StringFieldUpdateOperationsInput
  data: StringFieldUpdateOperationsInput
  decodedDataJson: StringFieldUpdateOperationsInput
  recipient: StringFieldUpdateOperationsInput
  attester: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  timeCreated: IntFieldUpdateOperationsInput
  expirationTime: IntFieldUpdateOperationsInput
  revocationTime: IntFieldUpdateOperationsInput
  refUID: StringFieldUpdateOperationsInput
  revocable: BoolFieldUpdateOperationsInput
  revoked: BoolFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  ipfsHash: StringFieldUpdateOperationsInput
  isOffchain: BoolFieldUpdateOperationsInput
}

input AttestationUpdateWithWhereUniqueWithoutSchemaInput {
  where: AttestationWhereUniqueInput!
  data: AttestationUpdateWithoutSchemaInput!
}

input AttestationUpdateManyWithWhereWithoutSchemaInput {
  where: AttestationScalarWhereInput!
  data: AttestationUpdateManyMutationInput!
}

input AttestationScalarWhereInput {
  AND: [AttestationScalarWhereInput!]
  OR: [AttestationScalarWhereInput!]
  NOT: [AttestationScalarWhereInput!]
  id: StringFilter
  data: StringFilter
  decodedDataJson: StringFilter
  recipient: StringFilter
  attester: StringFilter
  time: IntFilter
  timeCreated: IntFilter
  expirationTime: IntFilter
  revocationTime: IntFilter
  refUID: StringFilter
  revocable: BoolFilter
  revoked: BoolFilter
  txid: StringFilter
  schemaId: StringFilter
  ipfsHash: StringFilter
  isOffchain: BoolFilter
}

input SchemaNameCreateManyInput {
  id: String
  schemaId: String!
  attesterAddress: String!
  name: String!
  time: Int!
  isCreator: Boolean!
}

input SchemaNameCreateInput {
  id: String
  attesterAddress: String!
  name: String!
  time: Int!
  isCreator: Boolean!
  schema: SchemaCreateNestedOneWithoutSchemaNamesInput!
}

input SchemaCreateNestedOneWithoutSchemaNamesInput {
  create: SchemaCreateWithoutSchemaNamesInput
  connectOrCreate: SchemaCreateOrConnectWithoutSchemaNamesInput
  connect: SchemaWhereUniqueInput
}

input SchemaCreateWithoutSchemaNamesInput {
  id: String!
  schema: String!
  creator: String!
  resolver: String!
  revocable: Boolean!
  index: String!
  txid: String!
  time: Int!
  attestations: AttestationCreateNestedManyWithoutSchemaInput
}

input SchemaCreateOrConnectWithoutSchemaNamesInput {
  where: SchemaWhereUniqueInput!
  create: SchemaCreateWithoutSchemaNamesInput!
}

input SchemaNameUpdateInput {
  id: StringFieldUpdateOperationsInput
  attesterAddress: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  isCreator: BoolFieldUpdateOperationsInput
  schema: SchemaUpdateOneRequiredWithoutSchemaNamesNestedInput
}

input SchemaUpdateOneRequiredWithoutSchemaNamesNestedInput {
  create: SchemaCreateWithoutSchemaNamesInput
  connectOrCreate: SchemaCreateOrConnectWithoutSchemaNamesInput
  upsert: SchemaUpsertWithoutSchemaNamesInput
  connect: SchemaWhereUniqueInput
  update: SchemaUpdateWithoutSchemaNamesInput
}

input SchemaUpsertWithoutSchemaNamesInput {
  update: SchemaUpdateWithoutSchemaNamesInput!
  create: SchemaCreateWithoutSchemaNamesInput!
}

input SchemaUpdateWithoutSchemaNamesInput {
  id: StringFieldUpdateOperationsInput
  schema: StringFieldUpdateOperationsInput
  creator: StringFieldUpdateOperationsInput
  resolver: StringFieldUpdateOperationsInput
  revocable: BoolFieldUpdateOperationsInput
  index: StringFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  time: IntFieldUpdateOperationsInput
  attestations: AttestationUpdateManyWithoutSchemaNestedInput
}

input ServiceStatCreateManyInput {
  name: String!
  value: String!
}

input ServiceStatCreateInput {
  name: String!
  value: String!
}

input ServiceStatUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input ServiceStatUpdateInput {
  name: StringFieldUpdateOperationsInput
  value: StringFieldUpdateOperationsInput
}

input TimestampCreateManyInput {
  id: String!
  from: String!
  txid: String!
  tree: String
  timestamp: Int!
}

input TimestampCreateInput {
  id: String!
  from: String!
  txid: String!
  tree: String
  timestamp: Int!
}

input TimestampUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  from: StringFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  tree: StringFieldUpdateOperationsInput
  timestamp: IntFieldUpdateOperationsInput
}

input TimestampUpdateInput {
  id: StringFieldUpdateOperationsInput
  from: StringFieldUpdateOperationsInput
  txid: StringFieldUpdateOperationsInput
  tree: StringFieldUpdateOperationsInput
  timestamp: IntFieldUpdateOperationsInput
}
